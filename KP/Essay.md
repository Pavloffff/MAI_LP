# Реферат  

## по курсу "Логическое программирование"

### студент: Павлов Иван Дмитриевич

### группа: М8О-207Б-21

## ТЕМА: Логические языки как первые языки для обучения программированию  

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих*

## Введение

В качестве самого первого языка для начала изучения программированя подойдет, наверное, любой тьюринг-полный ЯП, вне зависимости от парадигмы и других особенностей, так как человек, совершенно незнакомый с принципами новой для него области работы, совершенно не подозревает о существовании каких-либо парадигм. Для него любой программный код сводится лишь к последовательности нулей, единиц и непонятных слов на английском языке. Поэтому логические языки вполне могут стать первыми языками для начинающих программистов, но вот необходимо ли именно с них начинать обучение? Я, как и абсолютное большинство программистов, начинал свое обучение с языков императивной парадигмы. Чтобы понять устройство, например, логического ЯП Prolog, мне пришлось буквально "сломать мозг", так как на подсознательном уровне постоянно происходило сравнение с императивными языками. Если же человек, абсолютно не знакомый с программированием, пройдет тот же путь, что и я, он поймет этот язык куда быстрее, ведь он не знаком с императивной парадигмой. Но в дальнейшем, например, тот же Си ему учить будет сложнее. Таким образом, принцип выбора первого языка предельно прост: нужно учить сразу тот язык, который востребован на текущий момент времени.

## Проблема логических языков

А что там с востребованностью логических языков? Самый яркий их представитель - Prolog - появился на свет еще в начале 70-х годов, однако на данный момент популярности особой не имеет. Редко где можно встретить промышленный проект, написанный на Прологе. Почему? На мой взгляд, как раз из-за парадигмы и относительной низкоуровневости. Prolog - это тот случай, когда программы очень понятны и легко читаемы, но при этом писать их очень сложно. Сама парадигма не основана на алгоритмических моделях, в которых в качестве базовых средств выступают модели императивных исполнителей (таких, как машина Тьюринга). Вместо этого в ее основе лежит логика предикатов первого порядка. Такой подход породил за собой "Комбинаторный взрыв" - проблему крайне высокой "экспоненциальной" сложности работы программы. Это, конечно же, связано с полным перебором всего дерева решений. Разработчик на Prolog постоянно сталкивается с необходимости отсеивать лишние и выбирать нужные решения. Это возможно только при наличии формального алгоритма. Но если алгоритм решения уже известен, то почему бы просто не написать его на более быстром Си или удобном Python? Но на самом деле это не проблема декларативных ЯП, это их фишка! Следует отказаться от построения каких-либо алгоритмов и предоставить это компьютеру. А тот, в свою очередь, выберет самый простой способ - обход дерева решений. А далее в Prolog это легко решается с помощью зеленого и красного отсечений, однако это все равно сведется к перебору. Так как же все-таки решить проблему производительности? Вариант с поиском более сложных алгоритмов типа быстрой сортировки Хоара отпадает сразу - это все решения на императивных языках. Оптимизировать следует не сам алгоритм, а выборку, таким образом, чтобы перебиралось как можно меньше решений. По сути все сводится именно к оптимизации входных данных.

## Декларативная парадигма в популярных языках

Однако не следует забывать, что Prolog и логическое программирование - не одно и то же. Если посмотреть на любую статистику популярности языков программирования, на одном из первых мест будет SQL. Как правило, он уступает лишь невероятно популярным языкам фронтенд разработки html/css/js и Python, однако иногда обходит C/C++ и Java. При этом SQL одной парадигмы с Прологом. Да-да, это декларативный язык. Реализации моделей на SQL и Prolog имеют общие черты. В SQL мы оперируем представлениями на основе таблиц, а в Prolog - правилами на основе фактов. По своей сути таблицы SQL это набор полей, предикаты Пролога - набор атрибутов. Теоретическая основа SQL - реляционная алгебра. Она теоретически связана с логическим программированием, и в конечном счете они опираются на одну математическую базу - логику предикатов первого порядка. Ввиду большей низкоуровневости, Пролог более гибкий и дает нам возможности для работы со сложными структурами. SQL же более востребован за счет встроенных алгоритмов обработки строк в реляционной БД. Так как практически в любой web-разработке используются базы данных, то SQL является одним из важнейших навыков для начинающего программиста.

Декларативная составляющая есть и в языке Python. Python - мультипарадигменный язык. Для демонстрации этого еще раз рассмотрим алгоритм Быстрой сортировки Хоара:
```Python
def quickSort(L):
    if L == [] return []
    H, T = L[0], L[1:]
    return quickSort([Y for Y in T if Y < T]) + [H] + quickSort(Y for Y in T if Y >= T)
```
Здесь легко можно заметить декларативную парадигму. Для сортировки списка необходима его рекурсивно разбить на левый (меньший) и правый (больший) подсписки, а затем их соединить. Здесь мы по сути реализовали предикат, разбили список на "голову" и "хвост", как в Prolog. Только вместо предиката findall используется цикл for, а вместо предиката concat - сложение списков. Чтобы продемонстрировать универсальность Python, вот полностью императивная реализация:
```Python
def partition(arr: list, n: int, p: int):
    i, j = 0, n - 1
    pivot = arr[p]
    while i <= j:
        while arr[i] < pivot:
            i += 1
        while arr[j] > pivot:
            i += 1
        if i <= j: 
            if arr[i] > arr[j]:
                swap(arr, i, j)
            i += 1
            j += 1

def quicksort(arr: list, n: int):
    p = get_pivot(arr, n)
    i = partition(a, n, p)
    quicksort(arr[0:i], i)
    quicksort(arr[i:len(arr)], n - i)
```
Здесь идея в том, что список делится на 2 части - левая (все числа, которые меньше опорного элемента pivot) и, соответственно, правая. Далее идут рекурсивные вызовы от меньшего и большего отрезков. Императивная реализация работает быстрее, но ее код не такой наглядный, как написанная в декларативном стиле. Ну и, соответственно, императивный код проще в реализации.

## Так нужно ли выбирать логический язык первым?

Безусловно, чтобы быть хорошим специалистом, необходимо знать не только императивную парадигму, так как иногда возможны более простые способы, используя ЛП. Но вот выбирать ли логический язык первым или нет - зависит уже от сферы деятельности, в который человек, собирающийся стать программистом, хочет работать. Например, заинтересовавшись устройством баз данных, можно начать изучать первым языком SQL, и, чтобы расширить понимание принципов работы, можно попытаться понять и Prolog. Тем более, если человек хорошо понимает логику предикатов первого порядка, однако по каким-то причинам не умеет программировать, логические языки - одно из лучших решений для легкого вхождения в it. Кроме того, на мой взгляд, понять, например, язык Python, изначально зная лишь Пролог или SQL куда проще, чем понять Prolog, зная Python, опять же из-за привычных императивных алгоритмов. Таким образом, можно утверждать, что Декларативная парадигма имеет место быть и такие языки хорошо подходят как первые языки для обучения программированию.

## Использованная литература

Д.В. Сошников Парадигма логического программирования
https://habr.com/ru/post/322900/
https://habr.com/ru/post/430964/
https://habr.com/ru/post/496092/
https://bbbl.dev/articles/choose-your-first-programming-language
https://habr.com/ru/post/536268/
https://habr.com/ru/post/124636/
https://habr.com/ru/post/522530/
https://habr.com/ru/post/459779/
https://www.instituteiba.by/courses/it/oracle/column-expert/sql-who-needs-and-how-does-it-help/
