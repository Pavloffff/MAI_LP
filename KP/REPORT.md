# Отчет по курсовому проекту
## по курсу "Логическое программирование"

### студент: <Фамилия Имя Отчество>

## Результат проверки

Вариант задания:

 - [x] стандартный, без NLP (на 3)
 - [ ] стандартный, с NLP (на 3-4)
 - [ ] продвинутый (на 3-5)
 
| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*

## Введение

В рамках выполнения курсового проекта я рассчитываю получить навыки работы с генеалогическими деревьями в формате GEDCOM, навыки создания парсеров, а также улучшить навыки работы с предикатами Prolog.

## Задание

1. Создать родословное дерево своего рода на несколько поколений (3) назад в стандартном формате [GEDCOM].

2. Преобразовать файл в формате GEDCOM в набор утверждений на языке Prolog, с использованием предиката `parents(потомок, отец, мать)`. Для преобразованиa использовался язык Python.
 
3. Реализовать предикат проверки/поиска следующих родственников: Двоюродный брат. 

4. Реализовать программу на языке Prolog, которая позволит определять степень родства двух произвольных индивидуумов в дереве.

## Получение родословного дерева

Родословное дерево было получено с помощью программы Gramps, в нем 35 человек.

## Конвертация родословного дерева

Я использовал язык Python для конвертации дерева в предикаты, потому что он простой.

## Предикат поиска родственника

Я написал предикат поиска родственника, используя алгоритм поиска в ширину.

```Prolog
rodstvo(X, Y) :-
    parents(X, _, Y); 
    parents(Y, X, _); 
    parents(Y, _, X); 
    parents(X, Y, _).

prolong([H|T], [New, H|T]) :-
    rodstvo(H, New),
    not(member(New, [H|T])).

bfs([[F|T]|_], F, [F|T]).
bfs([R|S], F, R1):-
    findall(W, prolong(R,W), J),
    append(S, J, K),
    bfs(K, F, R1).
```

## Определение степени родства

Для определения степени родства было использовано перевод пути из набора людей в набор простых отношений, который с помощью предиката searchSophMap искал всевозможные замены более сложными отношениями.
```Prolog
map(child, X, Y) :-
    parents(Y, X, _);
    parents(Y, _, X).

map(dad, X, Y) :-
    parents(X, Y, _).

map(mom, X, Y) :-
    parents(X, _, Y).

mapping([_], []).
mapping([X,Y|T], [R1|R]) :-
    map(R1, X, Y),
    mapping([Y|T], R).

parent(mom).
parent(dad).

sophisticatedMap(cousin, [P1, P2, child, child]) :-
    parent(P1),
    parent(P2).

sophisticatedMap(sibling, [P1, child]) :-
    parent(P1).

searchSophMap(R, R1) :-
    append(S, X, R), append(Y, E, X),
    sophisticatedMap(T1, Y),
    append(S, [T1|E], T),
    searchSophMap(T, R1).
searchSophMap(R, R).

relative(T, X, Y) :-
    bfs([[X]], Y, RP),
    reverse(RP, R1),
    mapping(R1, R),
    searchSophMap(R, T).
```
Определение таких сложных отношений, как Двоюродный брат или сестра реализованы в функции sophisticatedMap.

результат работы программы:

```Prolog
?- relative([cousin], 'Иван Павлов', X).
X = 'Елена Таран' ;
X = 'Светлана Таран' ;
X = 'Елена Таран' ;
X = 'Светлана Таран' ;
;false.
```

## Выводы

Написав данный курсовой проект, я познакомился с новым типом файлов GEDCOM, а также применил свои навыки в программировании на языке Python. Помимо этого основной частью моей работы являлось закрепление навыков обращения с предикатами языка Prolog, в этом мне помогло решение прикладной задачи, связанной с различными родственными связями.