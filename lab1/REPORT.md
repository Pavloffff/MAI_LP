# Отчет по лабораторной работе №1
## Работа со списками и реляционным представлением данных
## по курсу "Логическое программирование"

### студент: Павлов И.Д.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |


## Введение

В Прологе, в отличии от большинства императивных языков, используется другой подход к хранению последовательности данных: используется логика предикатов, однако для простоты введена привычная скобочная нотация. Список в Прологе состоит из головы (1-го элемента), и хвоста (остальных элементов), возможен доступ отдельно к голове и рекурсивно ко всем элементам хвоста. Списки в Прологе похожи на очередь, в ней тоже есть доступ только к "голове", однако мы не можем пройтись по очереди рекурсивно, не разрушая ее. Также списки в Прологе похожи на односторонние линейные списки в Си, реализованные на указателях (изначально доступна только "голова"), а также чем-то на двоичное дерево, у которого любое левое поддерево является листом.

## Задание 1.0: Стандартные предикаты

```prolog
length([],0).
length([X|T],N) :- length(T,N1), N is N1+1.

member(A, [A|_]).
member(A, [_|Z]) :- member(A, Z).

append([], L, L).
append([X|T], L, [X|R]) :- append(T, L, R).

remove(X, [X|T], T).
remove(X, [Y|T], [Y|T1]) :- remove(X, T, T1).

permute([], []).
permute(L, [X|T]) :- remove(X, L, R), permute(R, T).

sublist(R, L) :- append(_, T, L), append(R, _, T).
```

## Задание 1.1: Предикат обработки списка

`shiftRightSt(L, N, S)` - Циклический сдвиг списка вправо, используя стандартные предикаты, на N шагов.

Примеры использования:
```prolog
?- shiftRightSt([1, 3, 5, 7], 1, X).
X = [7, 1, 3, 5] .
```

Реализация:
```prolog
length([],0).
length([X|T],N) :- length(T,N1), N is N1+1.

append([], L, L).
append([X|T], L, [X|R]) :- append(T, L, R).

shiftRightSt(L, N, S) :-
    append(X, Y, L),
    length(Y, N),
    append(Y, X, S).

```

Принцип работы: Исходный список разделяется на левую и правую части. Для правой части длина списка должна быть равна шагу сдвига N. Первые 2 шага алгоритма будут выполняться до тех пор, пока списки не будут разделены так, что размер правой части будет равен N. Левая и правая части меняются местами (справа ставится левая, а слева — правая).

`shiftRightNSt([H|T])` - Циклический сдвиг списка вправо, на одну позицию, не используя стандартные предикаты.

Примеры использования:
```prolog
?- shiftRightNSt([1, 3, 5, 7]).
7 1 3 5 
true .
```

Реализация:
```prolog
delFirst([_|[]]).
delFirst([H|T]) :- 
    write(H), 
    write(" "),
    delFirst(T).

delLast([_|T]) :- delLast(T).
delLast([T]) :- write(T).

shiftRightNSt([H|T]) :- 
    delLast(T),
    write(" "),
    write(H),
    write(" "),
    delFirst(T)
```

Принцип работы: сначала рекурсивно печатаем хвост, потом печатаем голову, таким образом выведется список, сдвинутый на 1 позицию вправо.

## Задание 1.2: Предикат обработки числового списка

`min(L,N)` - Находит минимум в числовом списке

Примеры использования:
```prolog
?- min([100, 4, 15, 1, 28], X).
X = 1.
```

Реализация:
```prolog
min([H],H).
min([H|T],H) :- min(T,N), H < N, !.
min([_|T],N) :- min(T,N).
```

Принцип работы: рекурсивно обходим список, находя минимальный элемент хвостов, результатом работы будет либо головной элемент, либо минимальный из хвоста.

## Задание 2: Реляционное представление данных

Преимущества реляционного представления: удобство для понимания, полная независимость данных, нет необходимости знать организацию данных во внешней памяти. <br>
Недостатки реляционного представления: низкая скорость, большой объем внешней памяти. <br>
Приимущества конкретного представления в файле three.pl: можно очень точно указать, что нужно искать в файле, при этом будет минимум "лишних" ответов, при хорошем запросе выходные данные очень точны. <br>
Приимущества конкретного представления в файле three.pl: иногда выходит сложночитаемый код запроса, сложно сделать выборку, не относящуюся к написанным в предикате student. 

## Задание 2.1. Для каждого студента, найти средний балл, и сдал ли он экзамены или нет.

### Реализация

```prolog
not(0, 1).
not(_, 0).

length([],0).
length([H|T],N) :- len(T,N1), N is N1+1.

sum([], 0).
sum([H|T], N) :- sum(T, N1), N is N1+H.

concat([], L2, L2).
concat([H|T], L2, [H|T1]) :-
    concat(T, L2, T1).

pass(X, "Не сдал") :- X = 0.
pass(X, "Сдал") :- X = 1.

grades_stud(Num, L) :-
    findall(X, student(_, Num, [grade('LP',X),grade('MTH',_),grade('FP',_),grade('INF',_),grade('ENG',_),grade('PSY',_)]), LP),
    findall(X, student(_, Num, [grade('LP',_),grade('MTH',X),grade('FP',_),grade('INF',_),grade('ENG',_),grade('PSY',_)]), M),
    findall(X, student(_, Num, [grade('LP',_),grade('MTH',_),grade('FP',X),grade('INF',_),grade('ENG',_),grade('PSY',_)]), F),
    findall(X, student(_, Num, [grade('LP',_),grade('MTH',_),grade('FP',_),grade('INF',X),grade('ENG',_),grade('PSY',_)]), I),
    findall(X, student(_, Num, [grade('LP',_),grade('MTH',_),grade('FP',_),grade('INF',_),grade('ENG',X),grade('PSY',_)]), E),
    findall(X, student(_, Num, [grade('LP',_),grade('MTH',_),grade('FP',_),grade('INF',_),grade('ENG',_),grade('PSY',X)]), P),
    concat(LP, M, A),
    concat(F, I, B),
    concat(E, P, C),
    concat(A, B, D),
    concat(C, D, L1),
    concat([Num], L1, L).

stud_passed(X, R) :-
    grades_stud(X, [H|T]),
    member(2, T, P),
    not(P, R).

stud_sum_grades(X, R) :-
    grades_stud(X, [H|T]),
    sum(T, R).

stud_cnt_grades(X, R) :-
    grades_stud(X, [H|T]),
    length(T, R).

stud_avg_grade(X, R) :- 
    stud_sum_grades(X, S),
    stud_cnt_grades(X, C),
    R is S/C.

avg_print([]).
avg_print([H|T]) :-
    stud_avg_grade(H, R),
    stud_passed(H, P),
    pass(P, P1),
    write(H),
    write(" | "),
    write(R),
    write(" | "),
    write(P1),
    write('\n'),
    avg_print(T).

task1(S) :-
    findall(S, student(_, S, _), L),
    write("Студент | Средний балл | Cдал/не сдал\n"),
    avg_print(L).
```

### Список реализованных предикатов

<ul>    
    <li>not(X, Y). - Инвертирует число X.</li>
    <li>length(L, X). - Длина списка L.</li>
    <li>sum(L, X). - Сумма чисел списка L.</li>
    <li>concat(L1, L2, L). - Объединяет 2 списка в 1.</li>
    <li>pass(X, A). - A принимает значение "сдал" при Х = 1, и "Не сдал" при Х = 0.</li>
    <li>grades_stud(Num, L). - Возвращает список всех оценок студента Num. </li>
    <li>stud_passed(X, R). - Возвращает 0 или 1, в зависимости от того, сдал студент или нет.</li>
    <li>stud_sum_grades(X, R). - Возвращает сумму оценок студента X.</li>
    <li>stud_cnt_grades(X, R). - Возвращает количество оценок студента X.</li>
    <li>stud_avg_grade(X, R). - Возвращает средний балл студента X.</li>
    <li>avg_print(L). - Печатает результат для cписка студентов.</li>
    <li>task1(S). - Получаем список студентов, затем вызываем от него avg_print. </li>
</ul>

### Результат работы программы

```prolog
?- task1(S).
Студент | Средний балл | Cдал/не сдал
Петров | 4 | Сдал
Петровский | 3.6666666666666665 | Не сдал
Иванов | 4 | Сдал
Ивановский | 3.5 | Сдал
Запорожцев | 3.5 | Не сдал
Сидоров | 4 | Не сдал
Сидоркин | 3.3333333333333335 | Не сдал
Биткоинов | 4 | Сдал
Эфиркина | 3.8333333333333335 | Сдал
Сиплюсплюсов | 3.6666666666666665 | Сдал
Программиро | 4 | Сдал
Джаво | 4.166666666666667 | Сдал
Клавиатурникова | 3.1666666666666665 | Не сдал
Мышин | 3.6666666666666665 | Не сдал
Фулл | 4.333333333333333 | Сдал
Безумников | 4.333333333333333 | Сдал
Шарпин | 3.1666666666666665 | Не сдал
Круглосчиталкин | 3.8333333333333335 | Не сдал
Решетников | 4.166666666666667 | Сдал
Эксель | 3.8333333333333335 | Сдал
Текстописов | 3.8333333333333335 | Не сдал
Текстописова | 3.6666666666666665 | Сдал
Густобуквенникова | 4.333333333333333 | Сдал
Криптовалютников | 3.6666666666666665 | Сдал
Блокчейнис | 3.5 | Не сдал
Азурин | 4.333333333333333 | Не сдал
Вебсервисов | 4.333333333333333 | Сдал
Круглотличников | 4 | Сдал
true .
```

## Задание 2.2. Для каждого предмета, найти количество не сдавших студентов.

### Реализация

```prolog
task2(L) :-
    findall(X, student(_, X, [grade('LP',2),grade('MTH',_),grade('FP',_),grade('INF',_),grade('ENG',_),grade('PSY',_)]), LP),
    findall(X, student(_, X, [grade('LP',_),grade('MTH',2),grade('FP',_),grade('INF',_),grade('ENG',_),grade('PSY',_)]), MTH),
    findall(X, student(_, X, [grade('LP',_),grade('MTH',_),grade('FP',2),grade('INF',_),grade('ENG',_),grade('PSY',_)]), FP),
    findall(X, student(_, X, [grade('LP',_),grade('MTH',_),grade('FP',_),grade('INF',2),grade('ENG',_),grade('PSY',_)]), INF),
    findall(X, student(_, X, [grade('LP',_),grade('MTH',_),grade('FP',_),grade('INF',_),grade('ENG',2),grade('PSY',_)]), ENG),
    findall(X, student(_, X, [grade('LP',_),grade('MTH',_),grade('FP',_),grade('INF',_),grade('ENG',_),grade('PSY',2)]), PSY),
    length(LP, LPL),
    length(MTH, MTHL),
    length(FP, FPL),
    length(INF, INFL),
    length(ENG, ENGL),
    length(PSY, PSYL),
    write('Логическое программирование: '),
    write(LPL),
    write('\n'),
    write('Математический анализ: '),
    write(MTHL),
    write('\n'),
    write('Функциональное программирование: '),
    write(FPL),
    write('\n'),
    write('Информатика: '),
    write(FPL),
    write('\n'),
    write('Английский язык: '),
    write(FPL),
    write('\n'),
    write('Психология: '),
    write(PSYL),
    write('\n').
```

### Список реализованных предикатов

<ul>
    <li>task2(L). - ищет всех студентов с двойками, по определенным предметом, считает их количество и печатает.</li>
</ul>

### Результат работы программы

```prolog
?- task2(S).
Логическое программирование: 0
Математический анализ: 3
Функциональное программирование: 3
Информатика: 3
Английский язык: 3
Психология: 3
true.
```

## Задание 2.3. Для каждой группы, найти студента (студентов) с максимальным средним баллом.

### Реализация

```prolog
member(A, [], 0).
member(A, [A|_], 1).
member(A, [_|Z], X) :- member(A, Z, X).

sum([], 0).
sum([H|T], N) :- sum(T, N1), N is N1+H.

concat([], L2, L2).
concat([H|T], L2, [H|T1]) :-
    concat(T, L2, T1).

grades_stud2(Num, L) :-
    findall(X, student(_, Num, [grade('LP',X),grade('MTH',_),grade('FP',_),grade('INF',_),grade('ENG',_),grade('PSY',_)]), LP),
    findall(X, student(_, Num, [grade('LP',_),grade('MTH',X),grade('FP',_),grade('INF',_),grade('ENG',_),grade('PSY',_)]), M),
    findall(X, student(_, Num, [grade('LP',_),grade('MTH',_),grade('FP',X),grade('INF',_),grade('ENG',_),grade('PSY',_)]), F),
    findall(X, student(_, Num, [grade('LP',_),grade('MTH',_),grade('FP',_),grade('INF',X),grade('ENG',_),grade('PSY',_)]), I),
    findall(X, student(_, Num, [grade('LP',_),grade('MTH',_),grade('FP',_),grade('INF',_),grade('ENG',X),grade('PSY',_)]), E),
    findall(X, student(_, Num, [grade('LP',_),grade('MTH',_),grade('FP',_),grade('INF',_),grade('ENG',_),grade('PSY',X)]), P),
    concat(LP, M, A),
    concat(F, I, B),
    concat(E, P, C),
    concat(A, B, D),
    concat(C, D, L).

sum_student_grades([], 0).
sum_student_grades(Num, R) :-
    grades_stud2(Num, L),
    sum(L, R).

set([], []):-!.
set([X|X1], Y):-
      member(X, X1),
      !, set(X1, Y).
set([X|X1], [X|Y]):-
      !, set(X1, Y).

group_stud_list(Num, L) :- 
    findall(X, student(Num, X, Y), L).

max_grade([], 0).
max_grade([H|T], N) :-
    max_grade(T, B),
    sum_student_grades(H, A),
    A =< B, N is B.
max_grade([H|T], N) :-
    max_grade(T, B),
    sum_student_grades(H, A),
    A >= B, N is A.

max_grade_group([]).
max_grade_group([H|T]) :-
    group_stud_list(H, X),
    max_grade(X, N),
    findall(Y, (student(H, Y, _), sum_student_grades(Y, N)), L),
    write(H),
    write(": "),
    write(L),
    write("\n"),
    max_grade_group(T).

task3() :-
    findall(X, student(X, Y, Z), L1),
    set(L1, L2),
    max_grade_group(L2).
```

### Список реализованных предикатов

<ul>    
    <li>member(A, Z, X). - Инвертирует число X.</li>
    <li>sum(L, X). - Сумма чисел списка L.</li>
    <li>concat(L1, L2, L). - Объединяет 2 списка в 1.</li>
    <li>grades_stud2(Num, L). - Возвращает список всех оценок студента Num. </li>
    <li>set(L, R). - Удаляет из списка все повторения.</li>
    <li>group_stud_list(X, L). - Возвращает список всех студентов группы.</li>
    <li>max_grade(L, R). - Возвращает максимальную оценку студентов из списка L.</li>
    <li>max_grade_group(X, R). - Печатает список студентов с максимальным баллом из списка групп.</li>
    <li>task3(). - Получаем список групп, затем вызываем от него max_grade_group(). </li>
</ul>

### Результат работы программы

```prolog
?- task3().
101: [Безумников,Густобуквенникова]
104: [Фулл]
103: [Вебсервисов]
102: [Азурин]
true .
```

## Выводы

Реализация некоторых тривиальных для императивного программиста вещей на ЯП Пролог достаточно непривычная и сложная, но в то же время какой-нибудь непростой алгоритм или структура данных, требующая детального изучения, на Прологе может быть написана в несколько строчек, так как это высокоуровневый язык. Такие программы могут быть детально понятны для тех, кто хорошо владеет логикой предикатов и рекурсивными алгоритмами (именно алгоритмической моделью). В то же время для человека, пишущего в основном на Си-подобных языках, такая парадигма может вызвать массу проблем. Например, невозможно создать переменную-счетчик, изначально равную нулю: в прологе просто нет инициализации, вместо этого придется работать с предикатами, создавать дополнительный аргумент, думать как его рекурсивно увеличивать / уменьшать. Сами списки в Прологе реализованы понятно, туда можно помещать элементы разных типов (в Прологе другая типизация), но вот невозможность инициализации, доступа по индексу и других привычных вещей затрудняют процесс написания кода всем, кроме людей, хорошо разбирающихся в логике предикатов и остальной матлогике. В реальном мире на Прологе пишут в основном простые поисковые скрипты, но мне даже для таких целей проще пользоваться императивными ЯП. 
