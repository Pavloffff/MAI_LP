## Отчет по лабораторной работе №2
## по курсу "Логическое программирование"

## Решение логических задач

### студент: Павлов И. Д.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Существуют различные подходы к решению логических задач. Например, <b>метод порождения и проверки</b>, суть которого сводится к тому, что первый предикат генерирует множество исходных данных, которые затем проверяются вторым предикатом на предмет соответствия условию задачи. Также существует <b>метод ветвей и границ</b>, при котором значительные части общего дерева возможных решений отсекаются или вообще не рассматриваются.<br>
Так как условия логических задач похожи на набор фактов, который удобно записать с помощью логики предикатов, то Пролог хорошо подходит для написания решателей подобных задач.

## Задание

18. В нашем городе обувной магазин закрывается каждый понедельник, хозяйственный  каждый вторник, продовольственный  каждый четверг, а парфюмерный магазин работает только по понедельникам, средам и пятницам. В воскресенье все магазины закрыты. Однажды подруги Ася, Ира, Клава и Женя отправились за покупками, причем каждая в свой магазин и притом в один. По дороге они обменивались такими замечаниями. Ася. Женя и я хотели пойти вместе еще раньше на этой неделе, но не было такого дня, чтобы мы обе могли сделать наши покупки. Ира. Я не хотела идти сегодня, но завтра я уже не смогу купить то, что мне нужно. Клава. А я могла бы пойти в магазин и вчера и позавчера. Женя. А я могла бы пойти и вчера и завтра. Скажите, кому какой магазин нужен?

## Принцип решения

Для описания условий, связанных с работой магазинов, можно обойтись одним предикатом <b>closed</b>, который возвращает true для всех магазинов, которые закрыты в определенный день. Кроме того, понадобились следующие предикаты: 
<ul>
    <li> remove - удаление элемента из списка. Ищет все вхождения элемента K в список и удаляет их.
    <li> intersection - пересечение двух списков. Идет рекурсивно по списку X и проверяет, есть ли он в Y. Если есть, то он добавляется в R.
    <li> delete_occurrences - удаление подмножеств списка из списка. Проверяем неравенство элементов подмножества и списка, чтобы в случае равенства удалить элемент.
</ul>

Далее нам нужны следующие данные: список магазинов, открытых в определенный день. для этого с помощью <b>findall</b> ищем все закрытые магазины в <b>closed</b>, потом удалим найденный список из списка всех магазинов с помощью <b>delete_occurrences</b>. Еще необходимы дни, в которые открыты все магазины, так как по условию девочки могли собраться только в такой день. Для этого (с помощью <b>findall</b> и <b>delete_occurrences</b>) находим списки дней, в которые открыт магазин, для каждого магазина и находим их пересечение с помощью <b>intersection</b>. <br>
Затем читаем условие. Клава могла пойти вчера и позавчера. Поэтому ищем все магазины которые работают в эти 2 дня. С помощью пересечения находим нужный магазин. То же самое с Женей, но только дни указываем другие. Ирин магазин закрыт завтра, поэтому найдем все магазины, которые не работают в этот день и уберем из них магазины других девочек. Асин магазин найдем по остаточному принципу. <br>
Пример работы кода:

```Prolog
?- solve(X, R).
X = klava,
R = grocery ;
X = klava,
R = grocery ;
X = jenya,
R = shoe ;
X = jenya,
R = shoe ;
X = ira,
R = prefume ;
X = ira,
R = prefume ;
X = ira,
R = prefume ;
X = ira,
R = prefume ;
X = ira,
R = prefume ;
X = ira,
R = prefume ;
X = ira,
R = prefume ;
X = ira,
R = prefume ;
X = asa,
R = hardware .
```

Получается, что Клава пошла в продовольственный, Женя - в обувной, Ира в парфюмерный, Ася - в хозяйственный.

## Выводы


Данная лабораторная работа показала мне, что можно решать логические задачки в том числе и на Prolog. Язык удобнен для решения подобных задач. Данная задача была довольно простая, однако доставила мне определенные трудности. В частности, не хотелось писать сразу предикаты open и closed, хотелось обойтись только одним из них. Эта экономия привела к написанию еще большего количества кода и возможно к увеличению сложностной оценки за счет дополнительной рекурсии. Кроме того на запрос, как впрочем и в большинстве случаев, интерпретатор выдал множество правильных, но одинаковых решений. Возможно этого можно было и избежать. В целом Prolog позволяет решать подобные задачи, даже во много раз более сложные и с большим количеством вариантов для перебора и тем самым экономить время.
